%%-----------Chapters start-------------------------------------
%%-----------Chapter 1------------------------------------------
\chapter{A Concise Overview of A Python Regression Test Suite For a Web Application}
This thesis proposes a general-purpose python module for the implementation of high volume automated tests. To properly discuss the nuanced uses of the module, it is first critical to establish a "typical" industrial usage scenario.

To that end, this chapter describes the state of the art in the web test automation field, and walks through the construction of a web test suite for a popular open source relationship management site, Monica, available for use from the website \url{https://monicahq.org} as well for self-hosting from \url{https://github.com/monicahq/monica}. Later chapters will discuss implementation of the module for high volume long sequence regression testing as well as the industrial and academic context surrounding the practice of high volume automated testing.

The test suite discussed in this chapter is published in its entirety online at \url{https://github.com/elementc/monica-tests-traditional}. They are written against the 0.6.5 release of the Monica software, and may be run using Python 3.

\section{Technologies}
There are a considerable number of tools and libraries used in the development and execution of web application tests. Regardless of actual platform, there must be at least a browser driver, a test runner, and probably some set of inspection tools. As later chapters will use a Python library, the following Python-friendly libraries have been selected.

\subsection{Selenium}
The Selenium open source project is a library which permits the programatic control of a web browser. This library is ostensibly designed for automated testing purposes, but it may be used in any case where automated browser interaction is critical, including secretarial desktop automation, the development of testing tools, malicious purposes, and niche industrial purposes. It has a number of supported platforms, including Python and a purpose-built IDE. The general usage operational cycle is:
\begin{enumerate}
\item Instantiate a browser driver, selecting the type of web browser to be driven.
\item Load specific URLs using the driver's \texttt{get} method.
\item Query the loaded page using the driver's \texttt{find\_element} methods.
\item Interact with page components using the element objects and associated methods returned from the above step.
\end{enumerate}\citep{holmes2006automating, bruns2009web, razak2011agile, wang2009build, kaur2013comparative, kongsli2007security, artzi2011framework}

\subsection{Python Test Runners}
Test runners are executables that load test suites, execute selected subsets, and then report results. There are a number of different test runners in the Python ecosystem, varying in their usage, provided test libraries, and reporting capabilities. Common test runners like pytest and nose live in the Python package archive, and have many users. However, there is a test runner built into the Python standard library named unittest. In the interest of keeping the dependencies of this test suite down (and taking advantage of familiar, high quality documentation), we have selected the unittest library for the runner of this test suite. \citep{nielsen2014python, pajankar2017python}

\subsection{Developer Tools and Resources}
Test authors need to be able to inspect the web application under test from the UI perspective in order to effectively use Selenium. Historically, a web debugger such as Firefox's Firebug tool has been used to fill this requirement. In modern web development, however, the debugger and inspector are built directly into the desktop web browser. These are all roughly equivalent in capability, but for the purposes of this document we'll use terminology consistent with Google Chrome's Inspector toolkit, which can be accessed with the F12 key.\citep{odell2014browser}

\section{Architecture}
A typical web application test suite is built from three components: a collection of page object models, a set of configuration parameters, and a set of test sequence scripts. In most cases, these will be stored in similarly named directories (/pages/, /config/, and /tests/).

\subsection{Page Objects}
To abstract out much of the low level work associated with interacting with the system under test, a typical usage case is to write a Python class for each "page" of the web application, and for each class to have a function related to each of the low level interactions, eg setting a field to a value or pulling a string from the page title. In the constructor of the page object, common sanity checks are often run to ensure the system is in a good state. \citep{liu2000object, kung2000object, leotta2013improving, marchetto2008state}

\subsection{Configuration}
It is common for different environments to have different credentials and settings, for instance, a continuous integration server might deploy with one set of passwords while a developer workstation has another and a user acceptance test server has a third set. To that end, it is critical that such variances are captured corectly, often in a configuration file or by reading correct values from execution environment variables. This may also be sensitive to certain differences in environments, for instance the need to skip verification of emails by system or application of different sets of mock interfaces.

\subsection{Test Sequences}
With page interfaces well defined and a suite of configuration details available, actual test authorship becomes fairly simple, with files conformant to the selected test runner's interface being filled with sequences of fairly easy to understand, high-level steps. Most of the time, a test script will be authored for each user story in the requirements of the system under test. Scenario-based tests is usually the easiest for novice programmers to write, but advanced methods may include detailed tours of the system or even exhausive tests of certain featue sets in isolation: test scripts for each of a calendar, a mail client, a presentation tool, and a contacts manager in an office productivity suite.\citep{leotta2013capture}

\section{Building The Test Suite}
This section is still under development and depends of the completion of the "traditional" test suite for monica. It may need additional restructuring or refocusing depending on what the committee thinks, but in general this will at least detail the test authorship process. \citep{GitHubma29}. %TODO: FillMe

\subsection{Planning A Set Of Tests}
walkthrough of how to identify and abstract the list of program features to test, including building a list of actions to write \citep{nguyen2001testing} %TODO: FillMe

\subsection{Determining DOM Object Identification Methods}
In order to be able to construct a proper page action, it is critical that our test code is able to interact with the right specific parts of the page under test. In Selenium, we use the driver's \texttt{find\_element\_by\_*} methods to do so. There are methods for finding page elements by many methods, including html ID, html name, link text and partial link text, css selectors, and several other more unique methods like an xpath string or just the tag's name. All of these methods are convenience wrappers for a base method named find\_element that takes a special constant from the \texttt{selenium.webdriver.common.by.By} class, such as \texttt{By.ID} or \texttt{By.CSS\_SELECTOR}.

While it may be more immediately readable to write test code using the convenience methods, this does have an effect on maintainability in that if a particular field must change the method it is found by, many function calls will need to be replaced. To prevent such a replacement nightmare, we can use python tuples and the unzip (splat) operator to combine a method of selection with a string constant as a single "element selector" field which may universally be consumed by a \texttt{find\_element} function call.

Consider this HTML tag:

{\tt
\begin{verbatim}
<input
  type="email"
  class="form-control"
  id="email"
  name="email"
  value=""
>
\end{verbatim}
}

This has a number of useful atributes we could use as a selector, but the best of all is the id field. HTML ids must be unique in an html document \citep{HTMLStan99} so selection by ID is extremely resillient. Here's a selector and a call to \texttt{find\_element} for the id "email":

{\tt
\begin{verbatim}
email_sel = (By.ID, "email")
email_field = driver.find_element(*email_sel)
\end{verbatim}
}

While selecting by the id field is comparatively simple (application authors may wish to give constant ids to parts of their applications they know will be involved in testing), selection by other methods is more complex. Consider this HTML tag:

{\tt
\begin{verbatim}
<button
  type="submit"
  class="btn btn-primary"
>
  Login
</button>
\end{verbatim}
}

This button is critical, it must be clicked in order to complete a login! However, it lacks a unique ID. It is tempting to use the \texttt{By.LINK\_TEXT} selection method since it has a fairly concise body text ("Login"), but this won't work since it's a \texttt{<button>} tag and not an \texttt{<a>} (anchor, a hyperlink base) tag. The next logical option is to select by class, the class attribute of html being whitespace-separated tags which are not guaranteed to be unique. If the software is designed to use classes in a way that relevant tags will be unique, this is an option, but it is not typical. In this case, the button has the btn and btn-primary classes, an identically styled button would have the same set of classes. This, then, is a candidate for improvement in the system under test, to at least provide a cleaner testing interface in the form of a unique id or class on this button, but in the interim we can fall back to HTML's built-in selection system, the CSS selector.

A CSS selector is a string confomrant to the CSS selection grammar \citep{Selector54} which enables detailed selection of DOM element or elements. It can combine an element's tag, id, class, parents, children, even positon. For the purposes of this login button's selection, we require the following features of candidate elements:
\begin{itemize}
\item Tag named button
\item Classes btn and btn-primary
\item First on the page
\end{itemize}

The following CSS selector satisfies these requirements:

\texttt{button.btn.btn-primary:nth-of-type(1)}.

Here's a python example:
{\tt
\begin{verbatim}
login_sel = (By.CSS_SELECTOR, "button.btn.btn-primary:nth-of-type(1)")
login_button = driver.find_element(*login_sel)
\end{verbatim}
} \citep{gupta2003dom,DOMStand78, nicholus2016understanding}


\subsection{Scripting Actions}
Now that each relevant element of the web page under test has a unique identifier for our use, the next step is to write the code that actually triggers the interactions with them. This is fairly straightforward, we use the Page Object's driver field to retrieve elements using these identifiers, then take actions on those elements.

The following snippet from our login page test retrieves an email text field and a password text field by their html IDs, as well as a login button by a css selector. These elements are then interacted with via the \texttt{send\_keys()} and \texttt{click()} methods. Note that \texttt{self.username} and \texttt{self.password} are defined in the object constructor from some secure source of testing account credentials.

{\tt
\begin{verbatim}
email_sel = (By.ID, "email")
password_sel = (By.ID, "password")
login_btn_sel = (By.CSS_SELECTOR, "button.btn.btn-primary")
def log_in_correctly(self):
  email_field = self.driver.find_element(*self.email_sel)
  password_field = self.driver.find_element(*self.password_sel)
  login_button = self.driver.find_element(*self.login_btn_sel)
  email_field.send_keys(self.username)
  password_field.send_keys(self.password)
  login_button.click()
\end{verbatim}
}

\subsection{Asserting Validity}
assert() 101 %TODO: FillMe

\subsection{Assembling The Final Test Scripts}
building (and running) a suite %TODO: FillMe
