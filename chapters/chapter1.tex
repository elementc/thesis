%%-----------Chapters start-------------------------------------
%%-----------Chapter 1------------------------------------------
\chapter{A Concise Overview of A Python Regression Test Suite For a Web Application}
This thesis proposes a general-purpose python module for the implementation of high volume automated tests. To properly discuss the nuanced uses of the module, it is first critical to establish a "typical" industrial usage scenario.

To that end, this chapter describes the state of the art in the web test automation field, and walks through the construction of a web test suite for a popular open source relationship management site, Monica, available for use from the website \url{https://monicahq.org} as well for self-hosting from \url{https://github.com/monicahq/monica}. Later chapters will discuss implementation of the module for high volume long sequence regression testing as well as the industrial and academic context surrounding the practice of high volume automated testing.

The test suite discussed in this chapter is published in its entirety online at \url{https://github.com/elementc/monica-tests-traditional}. They are written against the 0.6.5 release of the Monica software, and may be run using Python 3.

\section{Technologies}
There are a considerable number of tools and libraries used in the development and execution of web application tests. Regardless of actual platform, there must be at least a browser driver, a test runner, and probably some set of inspection tools. As later chapters will use a Python library, the following Python-friendly libraries have been selected.

\subsection{Selenium}
The Selenium open source project is a library which permits the programatic control of a web browser. This library is ostensibly designed for automated testing purposes, but it may be used in any case where automated browser interaction is critical, including secretarial desktop automation, the development of testing tools, malicious purposes, and niche industrial purposes. It has a number of supported platforms, including Python and a purpose-built IDE. The general usage operational cycle is:
\begin{enumerate}
\item Instantiate a browser driver, selecting the type of web browser to be driven.
\item Load specific URLs using the driver's \texttt{get} method.
\item Query the loaded page using the driver's \texttt{find\_element} methods.
\item Interact with page components using the element objects and associated methods returned from the above step.
\end{enumerate}\citep{holmes2006automating, bruns2009web, razak2011agile, wang2009build, kaur2013comparative, kongsli2007security, artzi2011framework}

\subsection{Python Test Runners}
Test runners are executables that load test suites, execute selected subsets, and then report results. There are a number of different test runners in the Python ecosystem, varying in their usage, provided test libraries, and reporting capabilities. Common test runners like pytest and nose live in the Python package archive, and have many users. However, there is a test runner built into the Python standard library named unittest. In the interest of keeping the dependencies of this test suite down (and taking advantage of familiar, high quality documentation), we have selected the unittest library for the runner of this test suite. \citep{nielsen2014python, pajankar2017python}

\subsection{Developer Tools and Resources}
Web Inspector, probably others\citep{odell2014browser}

\section{Architecture}
How web application tests are built

\subsection{Page Objects}
object oriented way of encapsulating all the things you can do on one page in a class \citep{liu2000object, kung2000object, leotta2013improving, marchetto2008state}

\subsection{DOM Identifiers And Other Constants}
discussion of how we tie python abstractions to web page elements \citep{gupta2003dom,DOMStand78, nicholus2016understanding}

\subsection{Test Sequences}
how individual tests are built as a sequence of page object actions \citep{leotta2013capture}

\section{Building The Test Suite}
how to build the base test suite for the particular SUT we're discussing. may cite the boilerplate, \citep{GitHubma29}.

\subsection{Planning A Set Of Tests}
walkthrough of how to identify and abstract the list of program features to test, including building a list of actions to write \citep{nguyen2001testing}

\subsection{Determining DOM Object Identification Methods}
In order to be able to construct a proper page action, it is critical that our test code is able to interact with the right specific parts of the page under test. In Selenium, we use the driver's \texttt{find\_element\_by\_*} methods to do so. There are methods for finding page elements by many methods, including html ID, html name, link text and partial link text, css selectors, and several other more unique methods like an xpath string or just the tag's name. All of these methods are convenience wrappers for a base method named find\_element that takes a special constant from the \texttt{selenium.webdriver.common.by.By} class, such as \texttt{By.ID} or \texttt{By.CSS\_SELECTOR}.

While it may be more immediately readable to write test code using the convenience methods, this does have an effect on maintainability in that if a particular field must change the method it is found by, many function calls will need to be replaced. To prevent such a replacement nightmare, we can use python tuples and the unzip (splat) operator to combine a method of selection with a string constant as a single "element selector" field which may universally be consumed by a \texttt{find\_element} function call.

Consider this HTML tag:

{\tt
\begin{verbatim}
<input
  type="email"
  class="form-control"
  id="email"
  name="email"
  value=""
>
\end{verbatim}
}

This has a number of useful atributes we could use as a selector, but the best of all is the id field. HTML ids must be unique in an html document \citep{HTMLStan99} so selection by ID is extremely resillient. Here's a selector and a call to \texttt{find\_element} for the id "email":

{\tt
\begin{verbatim}
email_sel = (By.ID, "email")
email_field = driver.find_element(*email_sel)
\end{verbatim}
}

While selecting by the id field is comparatively simple (application authors may wish to give constant ids to parts of their applications they know will be involved in testing), selection by other methods is more complex. Consider this HTML tag:

{\tt
\begin{verbatim}
<button
  type="submit"
  class="btn btn-primary"
>
  Login
</button>
\end{verbatim}
}

This button is critical, it must be clicked in order to complete a login! However, it lacks a unique ID. It is tempting to use the \texttt{By.LINK\_TEXT} selection method since it has a fairly concise body text ("Login"), but this won't work since it's a \texttt{<button>} tag and not an \texttt{<a>} (anchor, a hyperlink base) tag. The next logical option is to select by class, the class attribute of html being whitespace-separated tags which are not guaranteed to be unique. If the software is designed to use classes in a way that relevant tags will be unique, this is an option, but it is not typical. In this case, the button has the btn and btn-primary classes, an identically styled button would have the same set of classes. This, then, is a candidate for improvement in the system under test, to at least provide a cleaner testing interface in the form of a unique id or class on this button, but in the interim we can fall back to HTML's built-in selection system, the CSS selector.

A CSS selector is a string confomrant to the CSS selection grammar \citep{Selector54} which enables detailed selection of DOM element or elements. It can combine an element's tag, id, class, parents, children, even positon. For the purposes of this login button's selection, we require the following features of candidate elements:
\begin{itemize}
\item Tag named button
\item Classes btn and btn-primary
\item First on the page
\end{itemize}

The following CSS selector satisfies these requirements:

\texttt{button.btn.btn-primary:nth-of-type(1)}.

Here's a python example:
{\tt
\begin{verbatim}
login_sel = (By.CSS_SELECTOR, "button.btn.btn-primary:nth-of-type(1)")
login_button = driver.find_element(*login_sel)
\end{verbatim}
}


\subsection{Scripting Actions}
Now that each relevant element of the web page under test has a unique identifier for our use, the next step is to write the code that actually triggers the interactions with them. This is fairly straightforward, we use the Page Object's driver field to retrieve elements using these identifiers, then take actions on those elements.

The following snippet from our login page test retrieves an email text field and a password text field by their html IDs, as well as a login button by a css selector. These elements are then interacted with via the \texttt{send\_keys()} and \texttt{click()} methods. Note that \texttt{self.username} and \texttt{self.password} are defined in the object constructor from some secure source of testing account credentials.

{\tt
\begin{verbatim}
email_sel = (By.ID, "email")
password_sel = (By.ID, "password")
login_btn_sel = (By.CSS_SELECTOR, "button.btn.btn-primary")
def log_in_correctly(self):
  email_field = self.driver.find_element(*self.email_sel)
  password_field = self.driver.find_element(*self.password_sel)
  login_button = self.driver.find_element(*self.login_btn_sel)
  email_field.send_keys(self.username)
  password_field.send_keys(self.password)
  login_button.click()
\end{verbatim}
}

\subsection{Asserting Validity}
assert() 101

\subsection{Assembling The Final Test Scripts}
building (and running) a suite
