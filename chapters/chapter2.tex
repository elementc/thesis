%%----------Chapter 2------------------------------------------
\chapter{Using Yeager To Generate Long Sequence Regression Tests}
The test suite assembled in the previous chapter is a great way for a software development team to verify that the core functionality of the system under test is fundamentally operational. When executed, it will test the few well-understood scenarios we have outlined consistently and, assuming enough assertions are present, thoroughly. In fact, the suite requires the entire process from the previous chapter in order to accomodate the additon of new scenarios.

It's a boring, tedious, and repetitious task that can be the entire career of a test engineer. However, as any test automator will know, tasks which are boring, tedious, and repetitious are ripe targets for computer automation, and the task of scenario authorship is no different.

This chapter will outline a method for adapting the existing test suite explored in the previous chapter, using a tool of our own authorship named Yeager, to enable the computer to generate scenarios automatically. Yeager is an MIT-open sourced python version 3 module, with source available at \url{https://github.com/elementc/yeager}. It provides a python annotation and a set of utility functions. Usage of Yeager's state transition annotation allows testers to quickly and easily map an existing suite of test code onto a state machine, in the form of a graph. This graph can then be traversed using the utility functions, thereby generating new test scenarios from the existing code.

\section{Software As A State Machine}
Consider the system under test, Monica. As a relationship management web site, it has a few obvious states it can be in: logged out and on the landing page, logged in and on the dashboard, viewing a list of contacts, viewing a list of journal entries, or viewing the settings page. This maps nicely to the page objects we defined in the previous chapter. Actions on those page objects assume a current state (eg, we're logged in and on the dashboard) and after execution theoretically are in a new state which may or may not be the same state (eg, the \texttt{Dashboard.click\_contacts\_button()} method transitions from the dashboard to the contacts list). In fact, most modern programs can be looked at as systems composed of a finite set of states (pages, in this case) with some state transitions (links) and a data context (the stuff you've already typed into the system in those states).

\subsection{States in Our Example System}
Let's consider Monica's pages, which are already built into our test suite, to be states.

We have: the login page (\texttt{Login}) and logging in takes us to the \texttt{Dashboard} which has tabs for the \texttt{Contacts} list and the \texttt{Journal} log. There's also a \texttt{Settings} page which has subpages for \texttt{Import}, \texttt{Export}, \texttt{Users}, and \texttt{Tags}.

The Dashboard and Contacts list both let us \texttt{AddAContact}, while the Journal tab lets us \texttt{AddAJournalEntry}. From a given \texttt{Contact}, one can \texttt{AddASignificantOther}, \texttt{AddAChild}, \texttt{UpdateJobInformation}, \texttt{AddANote}, \texttt{AddAnActivity}, \texttt{AddAReminder}, \texttt{AddAGift}, and \texttt{AddADebt}.

For the purpose of our discussions, these pages will constitute the entire set of states in the system under test. Conveniently, each of them is a python class.

\subsection{State Transitions As Actions In Our Example System}
identifies actions developed in chapter 1 as lines connecting dots in this graph we're looking at

\subsection{Our Example System, Illustrated}
overview of the system as a whole, fully rendered and illustrated

\subsection{Graph Connectedness}
"Is it possible to get from here to here?" and other questions, probably will introduce Dijkstra.

\subsection{Capturing Contextual State}
Yeah, getting past the login screen is cool, but there's other outside influences on the output of the program than just which page we're on

\subsection{Taking A Walk On The Graph: Long Sequence Testing}
introduce the concept of long sequence testing

\section{Yeager State Transition Annotations}
how to use yeager: mark up your existing code

\subsection{State Identifiers}
how to declare a state, formally

\subsection{Basic State Transition Annotations (The 0-arg Case)}
how to declare that a particular function is a transition from one declared state to another

\subsection{Using The Yeager Connectedness Tester}
how to check that yeager can see your states and transitions

\section{Yeager Test Harnesses}
in more advanced scenarios, we need to assist Yeager's execution

\subsection{Application Configuration}
where to put data yeager always needs

\subsection{Test Setup and Entry Point}
pulling a LSRT run up by its bootstraps, and what point on the graph the test starts at.

\subsection{Exit Point}
many scenarios won't deal with this, but how to note ways tests can end successfully.

\subsection{Application Context Storage}
sometimes a test needs more information than just what state we're in. this overviews how to store things relevant to tests (who's expected to be logged in, how many emails they have, how many contacts, etc for an email client app)

\subsection{Test Method Helpers}
special args to an annotation that specify a caller which pulls data from App Context Storage

\subsection{Yeager-Only Assertions}
hooks provided for each state transition which can make additonal assertions not in the original test

\subsection{The Yeager Logger}
how to know what happened

\subsection{Advanced State Transition Annotations (With Context From Harness)}
using the stuff from above to enable more rich/complex state transitions

\section{Yeager Test Plans}
the bread and butter, informing the test generator what you're wanting to do

\subsection{Run-To-Crash vs. Run-Finitely}
discussion of a couple scenarios the tester may wish to choose between

\subsection{Controlling The Path: Blacklists}
how to inform a test to NOT go to certain states

\subsection{Controlling The Path: Weights}
how to inform a test to prefer (or shun) certain states

\subsection{Controlling The Path: Visitation Limits}
how to limit the number of times a particular state should be visited (for instance, dont go to the logout state in this run, stay logged in)

\subsection{Additional Configuration}
tbd during Yeager development

\subsection{Executing Test Plans}
\texttt{python -m yeager run yplan.py}

\subsection{Interpreting Results And Logs}
what do logs look like anyways?
